[{invert}]
= Travailler en équipe ?

== Limites de bosser seul

* Capacité finie de travail
* Victime de propres biais
* On ne sait pas tout, tout le temps ?

== !

image:solo.gif[width="500"]

== Travailler en équipe ? Une si bonne idée ?

* ... Mais il faut communiquer ?
* ... Mais tout le monde ne sait pas tout ?
* ... Mais tout le monde y code pas pareil ?

== !

Collaborer c'est pas évident, mais il existe des outils et des methodes pour vous aider.

[.small]
Cela reste des outils, ça ne résoud pas tout non plus.

== Git multijoueur

* Git permet de collaborer assez aisément
* Chaque développeur crée et publie des commits...
* ... et rapatrie ceux de de ses camarades !
* C'est un outil très flexible... chacun peut faire ce qu'il lui semble bon !

== ... et (souvent) ça finit comme ça !

image:bloing.jpeg[]

== Quelques règles pour éviter ça !

[{invert}]
== Disclaimer

Attachez vous aux idées générales... les détails varient d'un projet à l'autre!

== Gestion des branches

* Les "versions" du logiciel sont maintenues sur des branches principales
(main, staging)
* Ces branches reflêtent l'état du logiciel
** **main**: version actuelle en production
** **staging**: prochaine version

== !

image:gitmulti1.svg[]

== Gestion des branches

* Chaque groupe de travail (développeur, binôme...)
** Crée une branche de travail à partir de la branche staging
** Une branche de travail correspond à *une chose à la fois*
** Pousse des commits dessus qui implémentent le changement

== !

image:gitmulti2.svg[]

== !

image:gitmulti3.svg[]

Quand le travail est fini, la branche de travail est mergée dans staging

== !

image:gitmulti4.svg[]

== Gestion des remotes

La grande question: où vivent ces branches ?

== Plusieurs modèles possibles

* Un remote pour les gouverner tous !
* Chacun son propre remote (et les commits seront bien gardés)
* ... whatever floats your boat!

== Un remote pour les gouverner tous

Tous les développeurs envoient leur commits et branches sur le même dépot remote

* (+) Simple a gérer
* (-) Nécessite que tous les contributeurs aient accès au dépot
** Adapté a l'entreprise, peu adapté au monde de l'open source

== !

image:remotemulti1.svg[]

== Chacun son propre remote

* Chaque contributeur possède son propre remote
* La motivation est le contrôle d'accès
** Tout le monde peut lire le dépot principal. Personne ne peut écrire desuss.
** Tout le monde peut dupliquer le dépot public et écrire sur sa copie.
** Toute modification du dépot principal passe par une procédure de revue.
* C'est le modèle poussé par GitHub !

== !

image:remotemulti2.svg[]

== Forks ! Forks everywhere !

Dans la terminologie GitHub:

* Un fork est un remote copié d'un dépot principal
** C'est la où les contributeurs poussent leur branche de travail.
* Les branches de version (main, staging...) vivent sur le dépot principal
* La procédure de de ramener un changement d'un fork vers un dépot principal s'appelle une **Pull Request (PR)**.

== Pull request et revue de code

* Demande de merge
* Discussion
* Revue de code
* Checks (Conflits, approval, et aussi ... CI!)

== Exercice Pull Request

* Mettez vous par deux
* Forkez le dépot de l'autre
* Rajoutez le dépot de l'autre comme remote de votre dépot local

[source,bash]
--
git remote add fork https://github.com/blallala/blublu
git checkout -b feature-branch
git commit -m "lololo"
git push fork feature-branch
# OPEN DA PR.
--

== CI avec PRs

* On a causé des embouts du tuyau, causons du tuyau !
* Events de PR

// Suite : projet 1.1
